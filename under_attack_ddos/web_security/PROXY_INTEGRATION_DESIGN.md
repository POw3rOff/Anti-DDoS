# Reverse Proxy / Load Balancer Integration Design

This document defines how the `under_attack_ddos` system integrates with Layer 7 proxies (Nginx, HAProxy, Envoy) to provide application-layer visibility and mitigation.

## 1. High-Level Architecture

The Reverse Proxy acts as both a **Sensor** (feeding logs to detectors) and an **Actuator** (enforcing decisions from the Mitigation Controller).

### Data Flow
1.  **Ingress (Observability):**
    *   Proxy receives HTTP/HTTPS traffic.
    *   Proxy streams structured access logs (JSON via Syslog/File) to `l7_log_parser.py`.
    *   *Key Fields:* `client_ip`, `user_agent`, `uri`, `method`, `status`, `request_time`.
2.  **Analysis:**
    *   L7 Detectors analyze the stream for anomalies (e.g., behavioral fingerprinting).
    *   Orchestrator determines "UNDER ATTACK" state.
3.  **Egress (Mitigation):**
    *   Mitigation Controller generates a **Dynamic Configuration** (e.g., `deny_list.conf` or Map file).
    *   Proxy reloads or hot-updates its state to apply rules.

## 2. Integration Strategy (Nginx Example)

We utilize a **Dynamic Include** strategy to avoid modifying the main `nginx.conf`.

### File Structure
```text
/etc/nginx/
├── nginx.conf                  # Main config (static)
├── conf.d/
│   └── app.conf                # App VirtualHost
└── security/
    ├── uad_main.conf           # Included by app.conf (Logic hook)
    ├── dynamic_denylist.conf   # Generated by Mitigation Controller
    └── dynamic_ratelimit.conf  # Generated by Mitigation Controller
```

### Configuration Logic
The `uad_main.conf` implements the "Fail-Open" logic:

```nginx
# Map variable based on Mitigation Mode (0=Off, 1=On)
# Populated/Reloaded by Controller
include /etc/nginx/security/mode.conf;

# If Mode is ACTIVE, check the denylist
map $remote_addr $block_verdict {
    include /etc/nginx/security/dynamic_denylist.conf;
    default 0;
}

# Enforcement Block
if ($block_verdict = 1) {
    return 429; # Or custom error page
}
```

## 3. Communication Channels

1.  **Logs -> Detector:**
    *   **Method:** UDP Syslog (fastest, non-blocking) or Tail File.
    *   **Format:** JSON.
2.  **Controller -> Proxy:**
    *   **Method:** File Write + Reload Signal (`systemctl reload nginx`).
    *   **Latency:** ~100-500ms (Acceptable for L7).
    *   **Alternative:** For high-velocity changes, use Nginx+ API or OpenResty `lua_shared_dict`.

## 4. Safety Model

### Default: Pass-Through
*   If the `under_attack_ddos` system crashes, the `dynamic_*.conf` files remain static.
*   If the config is corrupt, Nginx validation (`nginx -t`) prevents reload, keeping the old (working) config.

### "Soft" Mitigation First
*   **JS Challenge:** Instead of `return 403`, redirect suspicious IPs to a lightweight challenge page.
*   **Rate Limit:** Degrade experience (slow down) rather than blocking instantly.

## 5. Step-by-Step Implementation Plan

1.  **Observability Setup:**
    *   Configure Nginx `log_format` to emit JSON.
    *   Point L7 Detector to consume this log.
2.  **Control Plane Setup:**
    *   Create `web_security/templates/` with safe default config snippets.
    *   Update `mitigation_controller.py` to write IP lists to `dynamic_denylist.conf`.
3.  **Loop Closure:**
    *   Implement the reload command in the Mitigation Controller.
    *   Add validation step (`nginx -t`) before reloading.

## 6. Required Configuration Files

*   **`web_security/nginx_format.conf`**: The JSON log format definition.
*   **`web_security/blocklist_template.conf`**: Jinja2 template for IP blocking.
*   **`web_security/ratelimit_template.conf`**: Jinja2 template for `limit_req_zone`.
